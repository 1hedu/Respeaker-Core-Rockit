/* 
@file oscillator.c

@brief

This file contains the oscillator function which generates waveforms from wavetables and from 
resynthesizing wavetables to make for big fun. If you wanna, this is one of the most fun
places to play around because you can get truly creative and get really new sounds. Cheers!

@ Created by Matt Heins, HackMe Electronics, 2011
This file is part of Rockit.

    Rockit is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Rockit is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Rockit.  If not, see <http://www.gnu.org/licenses/>
*/


#include "oscillator.h"
#include "eight_bit_synth_main.h"
#include "pgmspace.h"
#include "wavetables.h"
#include "amp_adsr.h"



/*
Function: oscillator
Takes: unsigned char ucwaveshape - This tells the function which waveshape to generate
       unsigned int unsample_reference - This tells the function where we are in the wave cycle

Returns: unsigned char - An eight bit unsigned sample value.

This function takes a waveshape variable, a sample reference (where we are in the cycle), and a frequency 
and returns an appropriate 8 bit value for that point in the cycle.  It may take a wavetable directly, or 
add some together or some other math function to make some new time-varying waveshape.

*/
unsigned char 
oscillator(unsigned char uc_waveshape, unsigned int un_sample_reference, unsigned char uc_frequency){
	
	unsigned char	uc_temp,
					uc_interpolate_sample_1,
					uc_interpolate_sample_2,
					uc_interpolate_reference,
					uc_sample = 0,
					uc_morph_sample_1 = 0,
					uc_morph_sample_2 = 0,
					lfsr_bit,
					uc_sample_index,
					uc_table_modulus,
					uc_reverse_sample_index,
					uc_pitch_shift;
					
	unsigned int	un_temp,
					un_temp2,
					un_sample_calc = 0;
					
	signed int sn_temp;
					
	static unsigned char uc_morph_timer,
						 uc_morph_index,
						 uc_morph_state,
						 uc_phase_shifter,
						 uc_phase_shift_timer;
						 
	static unsigned int un_morph_index,
						lfsr = 0xACE1; 
	
	
	/*Some of the code in this file has not been space optimized. I did this to make it easier for me to develop. Work
	can be done to decrease the size of this code by creating functions to handle wavetable blending and morphing.*/

	if(uc_waveshape != 255)
	{
		
	

	/*The waveshape comes from a pot reading 0-255, but there are only 16 waveshapes, so divide by 16*/
	uc_waveshape >>= 4;

	/*The morph timer is used to control the change between different waveshapes. Each tick of the morph timer
	is one sample period. In this case, one morph timer increment is 1/32768 = 30 microseconds.*/
	
	if(g_uc_oscillator_midi_sync_flag == 1)
	{
		g_uc_oscillator_midi_sync_flag = 0;
		uc_morph_state = 0;
		
	//	un_morph_index = 0;
	//	uc_morph_timer = 0;
		
		uc_pitch_shift = 0;
	
		if(uc_waveshape !=  MORPH_7)
		{
			uc_morph_index = 0;
		}
	}


	/*Wavetable Blending Explained:
	A bunch of the wavetables below have blending going on. Rather than explain it every time. Here's
	what's going on.
	The wavetables are set up with 32 tables for 128 notes, that is 4 notes per table.
	In order to smooth the transition from table to table, we need to blend the tables together.
	We make a weighted average of 4 samples. 
	1st note = half current table + half table below/2
	2nd note = 3* current table + 1 from table below /4
	3rd note = 3* current table + 1 from table above
	4th note = half current table + half from table above /2
	Not so hard, n'est-ce pas?
	*/
					
	//switch statment for different waveshapes
	switch(uc_waveshape)
	{
		//Sin values are in a lookup table generated by calculating one cycle of a sine wave 
		case SIN:
			
			uc_temp = un_sample_reference >> 7;
			
			//To interpolate, we need the remainder which is what's discarded above.
			uc_interpolate_reference = un_sample_reference & 0x7F;
			
			//We need the first sample.
			uc_interpolate_sample_1 = G_AUC_SIN_LUT[uc_temp];

			//We need to get the next sample.
			uc_temp++;

			uc_interpolate_sample_2 = G_AUC_SIN_LUT[uc_temp];
						
			uc_sample = linear_interpolate(uc_interpolate_reference, uc_interpolate_sample_1, uc_interpolate_sample_2);
		
		break;

		case SQUARE:
		
			uc_table_modulus = uc_frequency%4;
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			/*This operation blends wavetables to minimize moving aliasing as the keyboard is played*/
			switch(uc_table_modulus)
			{
				case 0:

					un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				case 1:

					un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 2:

					un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 3:
					un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				default:
				
					un_sample_calc = 0;

				break;

			}
			
			uc_sample = (unsigned char) un_sample_calc;

		break;
							
		case RAMP:
			
			uc_table_modulus = uc_frequency%4;
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			/*This operation blends wavetables to minimize moving aliasing as the keyboard is played*/
			switch(uc_table_modulus)
			{
				case 0:

					un_sample_calc = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				case 1:

					un_sample_calc = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 2:

					un_sample_calc = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 3:
					un_sample_calc = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				default:
				
					un_sample_calc = 0;

				break;

			}
			
			uc_sample = (unsigned char) un_sample_calc;		
		
		break;

						
		case TRIANGLE:

			uc_table_modulus = uc_frequency%4;
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			/*This operation blends wavetables to minimize moving aliasing as the keyboard is played*/
			switch(uc_table_modulus)
			{
				case 0:

					un_sample_calc = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				case 1:

					un_sample_calc = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency--;
					un_sample_calc += pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 2:

					un_sample_calc = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc *= 3;
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 2;

				break;

				case 3:
					un_sample_calc = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					uc_frequency++;
					un_sample_calc += pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					un_sample_calc >>= 1;

				break;

				default:
				
					un_sample_calc = 0;

				break;

			}
			
			uc_sample = (unsigned char) un_sample_calc;	
				
		break;
					

		case MORPH_1:
			
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256

			if(uc_morph_timer == 0)
			{
				uc_morph_index++;
				uc_morph_timer = MORPH_1_TIME_PERIOD;
			}

			uc_morph_timer--;
		
			uc_morph_sample_1 = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

			uc_sample_index += 127;
			
			uc_morph_sample_2 = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

			un_temp = uc_morph_sample_1*uc_morph_index;
			un_temp2 = uc_morph_sample_2*(255 - uc_morph_index);

			un_temp += un_temp2;

			uc_sample = un_temp >> 8;



		break;

		case MORPH_2:

			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256

			if(uc_morph_timer == 0)
			{
				uc_morph_index++;
				
				uc_morph_timer = MORPH_2_TIME_PERIOD;
			}

			uc_morph_timer--;

			uc_phase_shift_timer--;

			if(uc_phase_shift_timer == 0)
			{
				uc_phase_shifter++;
				
				uc_phase_shift_timer = PHASE_SHIFT_TIMER_2;
			}
			
			uc_morph_sample_1 = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

			uc_sample_index += uc_phase_shifter;
			
			uc_morph_sample_2 = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

			un_temp = uc_morph_sample_1*uc_morph_index;
			un_temp2 = uc_morph_sample_2*(255 - uc_morph_index);

			un_temp += un_temp2;

		
			uc_sample = un_temp >> 8;

		break;

		case MORPH_3:
				
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			if(uc_morph_timer == 0)
			{
				uc_morph_index++;
				uc_morph_timer = 50;
			}

			uc_morph_timer--;
			
			uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
			uc_temp = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
			sn_temp = uc_temp - pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

			/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
			that the sample is never going to be over 255 or less than 0.*/
			if(sn_temp > 127)
			{
				uc_sample = 255;
			}
			else if(sn_temp < -128)
			{
				uc_sample = 0;
			}
			else
			{
				uc_sample = 128 + sn_temp;
			}

		break;
		
		case MORPH_4:

			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
		
			if(uc_morph_timer == 0)
			{
				if(uc_morph_state == 0)
				{
					uc_morph_index++;

					if(uc_morph_index == 255)
					{
						uc_morph_state = 1;
					}
				}
				else
				{
					uc_morph_index--;

					if(uc_morph_index == 0)
					{
						uc_morph_state = 0;
					}
				}

				uc_morph_timer = 250;
			}

			uc_morph_timer--;
			
			uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
			uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
			sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

			/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
			that the sample is never going to be over 255 or less than 0.*/
			if(sn_temp > 127)
			{
				uc_sample = 255;
			}
			else if(sn_temp < -128)
			{
				uc_sample = 0;
			}
			else
			{
				uc_sample = 128 + sn_temp;
			}

		break;
		
		case MORPH_5:
		
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256

			if(uc_morph_timer == 0)
			{
				un_morph_index++;
				uc_morph_timer = 10;
			}

			uc_morph_timer--;
			
			/*First enveloped oscillator*/
			if(un_morph_index < 255)
			{
				un_sample_calc = G_AUC_SIN_LUT[uc_sample_index];
				un_sample_calc *= G_AUC_RAMP_SIMPLE_WAVETABLE_LUT[un_morph_index];
				un_sample_calc >>= 8;
				uc_morph_sample_1 = (unsigned char) un_sample_calc;
			}				
			
			if(un_morph_index > 128 && un_morph_index < 383)
			{
				uc_temp = un_morph_index - 128;				
				
				un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
				un_sample_calc *= 255 - G_AUC_SIN_LUT[uc_temp];
				un_sample_calc >>= 8;
				uc_morph_sample_2 = (unsigned char) un_sample_calc;
				
			}
			
			un_sample_calc = uc_morph_sample_1 + uc_morph_sample_2;
			un_sample_calc = un_sample_calc >> 1;
			uc_sample = (unsigned char) un_sample_calc;

			if(un_morph_index == 383)
			{
				un_morph_index = 0;
			}
		
		break;
		
		case MORPH_6:
		
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256

			if(uc_morph_timer == 0)
			{
				un_morph_index++;
				uc_morph_timer = 50;
			}

			uc_morph_timer--;
			
			/*First enveloped oscillator*/
			if(un_morph_index < 255)
			{
				un_sample_calc = G_AUC_RAMP_SIMPLE_WAVETABLE_LUT[uc_sample_index];
				un_sample_calc *= G_AUC_RAMP_SIMPLE_WAVETABLE_LUT[un_morph_index];
				un_sample_calc >>= 8;
				uc_morph_sample_1 = (unsigned char) un_sample_calc;
			}				
			
			if(un_morph_index > 128 && un_morph_index < 383)
			{
				uc_temp = un_morph_index - 128;
				un_sample_calc = pgm_read_byte(&G_AUC_SQUARE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
				un_sample_calc *= 255 - G_AUC_SIN_LUT[uc_temp];
				un_sample_calc >>= 8;
				uc_morph_sample_2 = (unsigned char) un_sample_calc;
				
			}
			
			un_sample_calc = uc_morph_sample_1 + uc_morph_sample_2;
			un_sample_calc = un_sample_calc >> 1;
			uc_sample = (unsigned char) un_sample_calc;

			if(un_morph_index == 383)
			{
				un_morph_index = 0;
			}
		
		break;
		
		case MORPH_7:
		
			/*This morphing waveshape is a square wave with varying pulse width.*/
		
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
		
			/*This morphing waveshape is a square wave of varying pulse width*/
			if(uc_morph_timer == 0)
			{
				uc_morph_index++;
				uc_morph_timer = 25;
			}

			uc_morph_timer--;
			
			uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
			uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
			sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

			/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
			that the sample is never going to be over 255 or less than 0.*/
			if(sn_temp > 127)
			{
				uc_sample = 255;
			}
			else if(sn_temp < -128)
			{
				uc_sample = 0;
			}
			else
			{
				uc_sample = 128 + sn_temp;
			}
			
		
		break;
		
		case MORPH_8:
		
			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			if(uc_morph_timer == 0)
			{
				uc_morph_index++;
				uc_morph_timer = 5;
				
			}
			
			uc_morph_timer--;

			switch(uc_morph_state)
			{
				case 0:
				
					/*Triangle wave for ~20ms*/
					uc_sample = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
					
					if(uc_morph_index == 255)
					{
						uc_morph_state = 1;
					}
					
				break;
				
				case 1:
				
					/*Noise for ~20ms*/
					
					lfsr_bit = ((lfsr >> 15) ^ (lfsr >> 13) ^ (lfsr ^ 12) ^ (lfsr >> 10)) & 1;
					lfsr = (lfsr << 1) | (lfsr_bit); 
        
					uc_sample = (unsigned char) lfsr;
					
					if(uc_morph_index == 255)
					{
						uc_morph_state = 2;
					}
				
				
				break;
				
				case 2:
				
					/*Then square wave that goes skinny*/
					uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
					uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
					sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

					/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
					that the sample is never going to be over 255 or less than 0.*/
					if(sn_temp > 127)
					{
						uc_sample = 255;
					}
					else if(sn_temp < -128)
					{
						uc_sample = 0;
					}
					else
					{
						uc_sample = 128 + sn_temp;
					}
					
					if(uc_morph_index == 255)
					{
						uc_morph_state = 3;
					}
				
				break;
				
				case 3:
				
					/*Then hold it*/
					uc_morph_index = 255;
					
					/*Then square wave that goes skinny*/
					uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
					uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
					sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

					/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
					that the sample is never going to be over 255 or less than 0.*/
					if(sn_temp > 127)
					{
						uc_sample = 255;
					}
					else if(sn_temp < -128)
					{
						uc_sample = 0;
					}
					else
					{
						uc_sample = 128 + sn_temp;
					}
				
				break;
				
			}
			
		break;

		case MORPH_9:

			uc_frequency >>= 2;//Only 32 tables
			uc_sample_index = un_sample_reference>>7;//shift from 32768 to 256
			
			uc_morph_state = get_adsr_state();
			
			switch(uc_morph_state)
			{
				case 0:
				
					/*Triangle wave for attack*/
					uc_sample = pgm_read_byte(&G_AUC_TRIANGLE_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

				break;

				case 1:
				
					uc_morph_index = 127;
			
					uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
					uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
					sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

					/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
					that the sample is never going to be over 255 or less than 0.*/
					if(sn_temp > 127)
					{
						uc_sample = 255;
					}
					else if(sn_temp < -128)
					{
						uc_sample = 0;
					}
					else
					{
						uc_sample = 128 + sn_temp;
					}
				
				break;
				
				default:
				
					/*Then hold it for release*/
						if(uc_morph_timer == 0)
					{
						uc_morph_index++;
						uc_morph_timer = 10;
					}

					uc_morph_timer--;
			
					uc_reverse_sample_index = uc_sample_index - uc_morph_index;
			
					uc_temp = pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_sample_index]);
		
					sn_temp = uc_temp - pgm_read_byte(&G_AUC_RAMP_WAVETABLE_LUT[uc_frequency][uc_reverse_sample_index]);

					/*Now we'll have a positive or negative number. We have to center it around 127 and make sure
					that the sample is never going to be over 255 or less than 0.*/
					if(sn_temp > 127)
					{
						uc_sample = 255;
					}
					else if(sn_temp < -128)
					{
						uc_sample = 0;
					}
					else
					{
						uc_sample = 128 + sn_temp;
					}
				
				break;
				
			}

		break;

		case HARD_SYNC:

			uc_frequency >>= 3;
			uc_sample_index = un_sample_reference>>8;
			uc_sample = pgm_read_byte(&G_AUC_HARDSYNC_2_WAVETABLE_LUT[uc_frequency][uc_sample_index]);

		break;


		case NOISE:

			/*A pseudo random number is generated using a linear feedback shift register
			The polynomial expression used is: x^16 + x^14 + x^13 + x^11 + 1*/

			lfsr_bit = ((lfsr >> 15) ^ (lfsr >> 13) ^ (lfsr ^ 12) ^ (lfsr >> 10)) & 1;
			lfsr = (lfsr << 1) | (lfsr_bit); 
        
			uc_sample = (unsigned char) lfsr;

		break;
		
		case RAW_SQUARE:

			if(un_sample_reference > HALF_SAMPLE_MAX)
			{
				uc_sample = 255;
			}
			else
			{
				uc_sample = 0;
			}

		break;


		default:

			uc_temp = un_sample_reference >> 7;				
			uc_sample = G_AUC_SIN_LUT[uc_temp];
		
		break;

	}

 	return uc_sample;
				
}

unsigned char 
blend_wavetable(const unsigned char *p_uc_byte_address, unsigned char uc_note_number_modulus)
{
	unsigned int un_sample_calc;

	switch(uc_note_number_modulus)
			{
				case 0:

					un_sample_calc = pgm_read_byte(p_uc_byte_address);
					p_uc_byte_address--;
					un_sample_calc += pgm_read_byte(p_uc_byte_address);
					un_sample_calc >>= 1;

				break;

				case 1:

					un_sample_calc = pgm_read_byte(p_uc_byte_address);
					un_sample_calc *= 3;
					p_uc_byte_address--;;
					un_sample_calc += pgm_read_byte(p_uc_byte_address);
					un_sample_calc >>= 2;

				break;

				case 2:

					un_sample_calc = pgm_read_byte(p_uc_byte_address);
					un_sample_calc *= 3;
					p_uc_byte_address++;
					un_sample_calc += pgm_read_byte(p_uc_byte_address);
					un_sample_calc >>= 2;

				break;

				case 3:
					un_sample_calc = pgm_read_byte(p_uc_byte_address);
					p_uc_byte_address++;
					un_sample_calc += pgm_read_byte(p_uc_byte_address);
					un_sample_calc >>= 1;

				break;

				default:
				
					un_sample_calc = 0;

				break;

			}
	}			

	return (unsigned char) un_sample_calc;

}


/*
Linear Interpolation
The top 8 bits give us the index = x1
The bottom 8 bits give us the next index = x2
So, we add x1 + (x1-x2)*(bottom 7 bits)/128	
*/	
unsigned char 
linear_interpolate(unsigned char uc_reference, unsigned char uc_sample_1, unsigned char uc_sample_2)
{
	signed int sn_difference;
	unsigned char uc_result;
		
	sn_difference = uc_sample_2 - uc_sample_1;
	
	sn_difference *= uc_reference;
	
	sn_difference >>= 8;
	
	uc_result = uc_sample_1 + sn_difference;

	return uc_result;
	
}
